#-------------------------------------------------------------------------------
# Ethernet Timing
#-------------------------------------------------------------------------------
#
#  The Cyclone IV FPGA interfaces to DP83848CVV Ethernet PHY.  The PHY has the 
#  following interfaces:
#
#  Serial Management I/F
#  ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
#  output   wire  MDC
#  inout    wire  MDIO
#  
#  MAC TX I/F
#  ¯¯¯¯¯¯¯¯¯¯
#  input    wire  TX_CLK
#  output   wire  TX_EN
#  output   wire  TXD_0
#  output   wire  TXD_1
#  output   wire  TXD_2
#  output   wire  TXD_3
#
#  MAC RX I/F
#  ¯¯¯¯¯¯¯¯¯¯
#  input    wire  RX_CLK
#  input    wire  RX_DV
#  input    wire  RX_ER
#  input    wire  RXD_0
#  input    wire  RXD_1
#  input    wire  RXD_2
#  input    wire  RXD_3
#
#  Misc
#  ¯¯¯¯
#  input    wire  ETH_CRS
#  input    wire  ETH_COL
#  output   wire  CLK_ETH_25M
#  output   wire  ETH_RESET_N
#
#  (a)  Originally, the FPGA was going to source the clock to the PHY device.  
#       However the FPGA could not meet the jitter specs and as such is no 
#       longer providing this functionality.
#  (b)  The ethernet reset signal shall be driven by a register bit
#-------------------------------------------------------------------------------



#-------------------------------------------------------------------------------
#  Serial Management I/F
#  ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
#  output   wire  MDC
#  inout    wire  MDIO
#-------------------------------------------------------------------------------
# - source synchronous interface, single data rate
# - FPGA sources the clock signal, MDC
# - MDC clock frequency is configurable via MAC register
# - MDC clockout is generated by a register, which is clocked by:
#
#     nios2_bemicro_sopc_inst|the_pll|sd1|pll7|clk[1] <- 60 MHz
#
#  Therefore, the fastest clock that can be generated is a divide-by 2 of
#  the above PLL's clock frequency
#
#  Additionally, the Ethenert Phy is spec'ed for max MDC frequency of
#  25 MHz.  Therefore will use 25 MHz as upper limit.  In reality,
#  MDC would never be more the divide-by N of the above PLL's clock
#  frequency
#-------------------------------------------------------------------------------


# Define MDC as a clock node
# - this is a two step process
#   (a)  MDC output is generated by a register.  Declare
#        the output of the register as a clock node
#   (b)  The output of the register is tied to MDC FPGA 
#        I/O pin.  Define MDC FPGA I/O pin as a clock

# create alias for REALLY long instance name
set MDC_REG   "nios2_bemicro_sopc*altera_tse_mac*|mdio_clk"

# define MDC register as a clock node of 25 MHz
create_generated_clock -name MDC_REG_CLK \
                       -multiply_by 5 \
                       -divide_by 12 \
                       -source [get_pins $NIOS_PLL_CLK1] \
                       [get_registers $MDC_REG]

# define MDC FPGA IO pin as a clock node
create_generated_clock -name MDC_CLK \
                       -source [get_registers $MDC_REG] \
                       [get_ports MDC]


# From the PHY datasheet:
#  Tco_max     30 ns
#  Tco_min      0 ns
#  Tsu         10 ns
#  Th          10 ns
#
#  Assuming clock & data paths are trace delay matched
set Tco_max_mdio    30.000
set Tco_min_mdio     0.000
set Tsu_mdio        10.000
set Th_mdio        -10.000

set_input_delay -clock MDC_CLK -max $Tco_max_mdio [get_ports {MDIO}]
set_input_delay -clock MDC_CLK -min $Tco_min_mdio [get_ports {MDIO}]

# False pathing output timing.  Timing will be met by design
#set_output_delay -clock MDC_CLK -max $Tsu_mdio [get_ports {MDIO}]
#set_output_delay -clock MDC_CLK -min $Th_mdio  [get_ports {MDIO}]
set_false_path -to [get_ports {MDIO}]

# Add multicycle constraints for IO timing:
# - Since the data generated is generated by $NIOS_PLL_CLK1 in the 60 MHz
#   clock domain but data will be captured by MDC_CLK in 25 MHz domain,
#   multicycles apply
# - when transfering data from a fast clock domain to a related slow clock 
#   domain source multicycles can be used
set_multicycle_path -setup -start 3 -from [get_clocks $NIOS_PLL_CLK1] -to [get_clocks MDC_CLK] 
set_multicycle_path -hold  -start 2 -from [get_clocks $NIOS_PLL_CLK1] -to [get_clocks MDC_CLK] 

# Conversely:
# - Since the data generated by the external device is in the 25 MHz domain
#   but will be captured by $NIOS_PLL_CLK1 in the 60 MHz clock domain, 
#   multicycles apply
# - when transfering data from a slow clock domain to a related fast clock 
#   domain destination multicycles can be used
set_multicycle_path -setup -end 3 -from [get_clocks MDC_CLK] -to [get_clocks $NIOS_PLL_CLK1] 
set_multicycle_path -hold  -end 2 -from [get_clocks MDC_CLK] -to [get_clocks $NIOS_PLL_CLK1] 


# Lastly, since MDC register is forced into IO Element
# false path from register to pin because this delay is fixed
set_false_path -from [get_registers $MDC_REG] -to [get_ports {MDC}]



#-------------------------------------------------------------------------------
#  MAC TX I/F
#  ¯¯¯¯¯¯¯¯¯¯
#  input    wire  TX_CLK
#  output   wire  TX_EN
#  output   wire  TXD_0
#  output   wire  TXD_1
#  output   wire  TXD_2
#  output   wire  TXD_3
#-------------------------------------------------------------------------------
# - single data rate interface
# - Clock is source by the PHY device
# - two possible clock frequencies:
#     10 MBit   - clock is 2.5 MHz
#     100 MBit  - clock is 25 MHz
# - clock frequencies are mutually exclusive
# - Need two set of TX IO timings
#     (a)   10 Mbit TX IO timing
#     (b)   100 Mbit TX IO timing
#-------------------------------------------------------------------------------


# 100 Mbit TX Timing
# ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
#  Clock Frequency:      40 ns (typical)
#  Tsu:                  10 ns
#  Th:                    0 ns
#
#  - Assuming clock & data paths are trace delay matched

# Define 100 Mbit clock
create_clock -name TX_CLK25m  -period  40.000 [get_ports {TX_CLK}] -add

# Define datasheet parameters
set Tsu_100mbit_tx        10.000
set Th_100mbit_tx          0.000

# Setup/Hold Constraints
set_output_delay -clock TX_CLK25m -max $Tsu_100mbit_tx [get_ports "TX_EN TXD_?"] -add
set_output_delay -clock TX_CLK25m -min $Th_100mbit_tx  [get_ports "TX_EN TXD_?"] -add



# 10 Mbit TX Timing
# ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
#  Clock Frequency:     400 ns (typical)
#  Tsu:                  25 ns wrt falling edge of clock
#  Th:                    0 ns wrt rising edge of clock
#
#  - Data is captured on the falling edge
#  - Assuming clock & data paths are trace delay matched

# Define 10 Mbit clock
create_clock -name TX_CLK2m5  -period  400.000 [get_ports {TX_CLK}] -add

# Define datasheet parameters
set Tsu_10mbit_tx         25.000
set Th_10mbit_tx           0.000

# Worst case setup requirement:
# => Tsu + clock uncertainty
set Tsu_requirement_10mbit_tx    $Tsu_10mbit_tx

# Worst case hold requirement
# => Th + ½clock period + clock uncertainty
set clock_period [get_clock_info TX_CLK2m5 -period];           # determine clock period
set Th_requirement_10mbit_tx [expr -($Th_10mbit_tx + $clock_period/2.0)]

# Setup/Hold Constraints
set_output_delay -clock TX_CLK2m5 -clock_fall -max $Tsu_requirement_10mbit_tx [get_ports "TX_EN TXD_?"] -add
set_output_delay -clock TX_CLK2m5 -clock_fall -min $Th_requirement_10mbit_tx  [get_ports "TX_EN TXD_?"] -add


# Lastly, need to tell TimeQuest that these 
# clocks are mutually exclusive.  By this,
# only one given frequency is active at a time
set_clock_groups -exclusive -group {TX_CLK25m} -group {TX_CLK2m5}


#-------------------------------------------------------------------------------
#  MAC RX I/F
#  ¯¯¯¯¯¯¯¯¯¯
#  input    wire  RX_CLK
#  input    wire  RX_DV
#  input    wire  RX_ER
#  input    wire  RXD_0
#  input    wire  RXD_1
#  input    wire  RXD_2
#  input    wire  RXD_3
#-------------------------------------------------------------------------------
# - single data rate interface
# - Clock is source by the PHY device
# - two possible clock frequencies:
#     10 MBit   - clock is 2.5 MHz
#     100 MBit  - clock is 25 MHz
# - clock frequencies are mutually exclusive
# - Need two set of RX IO timing
#     (a)   10 Mbit RX IO timing
#     (b)   100 Mbit RX IO timing
#-------------------------------------------------------------------------------


# 100 Mbit RX Timing
# ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
#  Clock Frequency:      40 ns (typical)
#  Tco_max               30 ns
#  Tco_min               10 ns
#
#  - Assuming clock & data paths are trace delay matched

# Define 100 Mbit clock
create_clock -name RX_CLK25m  -period  40.000 [get_ports {RX_CLK}] -add

# Define datasheet parameters
set Tco_max_100mbit_rx      30.000
set Tco_min_100mbit_rx      10.000

# Setup/Hold Constraints
set_input_delay -clock RX_CLK25m -max $Tco_max_100mbit_rx [get_ports "RX_DV RX_ER RXD_?"] -add
set_input_delay -clock RX_CLK25m -min $Tco_min_100mbit_rx [get_ports "RX_DV RX_ER RXD_?"] -add


# 10 Mbit RX Timing
# ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
#  Clock Frequency:     400 ns (typical)
#  Tco_max              100 ns
#  Tco_min              100 ns
#
#  - Assuming clock & data paths are trace delay matched

# Define 100 Mbit clock
create_clock -name RX_CLK2m5  -period 400.000 [get_ports {RX_CLK}] -add

# Define datasheet parameters
set Tco_max_10mbit_rx    100.000
set Tco_min_10mbit_rx    100.000

# Setup/Hold Constraints
set_input_delay -clock RX_CLK2m5 -max $Tco_max_10mbit_rx [get_ports "RX_DV RX_ER RXD_?"] -add
set_input_delay -clock RX_CLK2m5 -min $Tco_min_10mbit_rx [get_ports "RX_DV RX_ER RXD_?"] -add


# Lastly, need to tell TimeQuest that these 
# clocks are mutually exclusive.  By this,
# only one given frequency is active at a time
set_clock_groups -exclusive -group {RX_CLK25m} -group {RX_CLK2m5}



#-------------------------------------------------------------------------------
#  Misc
#  ¯¯¯¯
#  input    wire  ETH_CRS
#  input    wire  ETH_COL
#  output   wire  ETH_RESET_N
#-------------------------------------------------------------------------------
# Timing information for these pins is not critical
# -> therefore false pathing them
#-------------------------------------------------------------------------------
set_false_path -from [get_ports ETH_CRS]
set_false_path -from [get_ports ETH_COL]

# Currently there is no logic driving ETH_RESET_N
# -> uncomment when necessary
#set_false_path -to [get_ports ETH_REsET_N]


